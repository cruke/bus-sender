// =======================
// SUSTAIN â€“ Bus Sender Backend (Apps Script)
// Matches current sender HTML payload
// =======================

/** Your Google Sheet ID (one sheet per Route will be created/used) */
const SPREADSHEET_ID = '1hBVwhIawyxcpr5Qj6MeDwYbmkSXLw1p-1x_pnLfEWN8';

/** How many latest rows to keep per Route sheet (excluding header). */
const MAX_POINTS = 1000;

/** Header order used in all Route sheets */
const HEADERS = ['timestamp', 'lat', 'lng', 'destination', 'driver', 'plate', 'speed_mps'];

function ss_() {
  return SpreadsheetApp.openById(SPREADSHEET_ID);
}

/** Ensure the Route sheet exists with correct headers (row 1, frozen). */
function getOrCreateSheet_(route) {
  const book = ss_();
  let sh = book.getSheetByName(route);
  if (!sh) {
    sh = book.insertSheet(route);
    sh.getRange(1, 1, 1, HEADERS.length).setValues([HEADERS]);
    sh.setFrozenRows(1);
    return sh;
  }
  // ensure header row matches
  const firstRow = sh.getRange(1, 1, 1, HEADERS.length).getValues()[0];
  const ok = firstRow.length === HEADERS.length &&
             firstRow.every((h, i) => String(h).trim().toLowerCase() === HEADERS[i]);
  if (!ok) {
    sh.getRange(1, 1, 1, HEADERS.length).setValues([HEADERS]);
    sh.setFrozenRows(1);
  }
  return sh;
}

/** Insert latest row at top (row 2) and prune to MAX_POINTS data rows. */
function insertTopAndPrune_(sh, rowObj) {
  // make room at row 2
  sh.insertRowsAfter(1, 1);
  const row = [
    rowObj.timestamp,
    rowObj.lat,
    rowObj.lng,
    rowObj.destination,
    rowObj.driver,
    rowObj.plate,
    rowObj.speed_mps
  ];
  sh.getRange(2, 1, 1, HEADERS.length).setValues([row]);

  // prune: keep rows 2 .. MAX_POINTS+1
  const lastRow = sh.getLastRow();
  const dataRows = Math.max(0, lastRow - 1);
  if (dataRows > MAX_POINTS) {
    const rowsToDelete = dataRows - MAX_POINTS;
    const startDelete = MAX_POINTS + 2; // header(1) + MAX_POINTS
    const finalRow = sh.getLastRow();
    if (startDelete <= finalRow) {
      sh.deleteRows(startDelete, Math.min(rowsToDelete, finalRow - startDelete + 1));
    }
  }
}

/** Helpers */
function num_(x, d) {
  const n = Number(x);
  return Number.isFinite(n) ? n : d;
}
function str_(x) {
  return (x == null) ? '' : String(x).trim();
}

/** ============ Web App Entrypoints ============ */

/** GET:
 *  - ?info=1  -> { ok:true, maxRows: MAX_POINTS }
 *  - else     -> simple message (optional)
 */
function doGet(e) {
  if (e && e.parameter && e.parameter.info === '1') {
    return ContentService
      .createTextOutput(JSON.stringify({ ok: true, maxRows: MAX_POINTS }))
      .setMimeType(ContentService.MimeType.JSON);
  }
  return ContentService
    .createTextOutput(JSON.stringify({ ok: true, message: 'SUSTAIN sender API: POST points here; use ?info=1 for config.' }))
    .setMimeType(ContentService.MimeType.JSON);
}

/** POST (Content-Type: text/plain; body = JSON):
 * {
 *   busId, driver, destination, plate,
 *   lat, lng, speed_mps, timestamp
 * }
 */
function doPost(e) {
  try {
    if (!e || !e.postData || !e.postData.contents) {
      return json_({ ok: false, error: 'Empty body' });
    }

    let data;
    try {
      data = JSON.parse(e.postData.contents);
    } catch (err) {
      return json_({ ok: false, error: 'Invalid JSON' });
    }

    const route = str_(data.busId) || 'UNKNOWN';
    const driver = str_(data.driver);
    const destination = str_(data.destination);
    const plate = str_(data.plate);
    const lat = num_(data.lat, NaN);
    const lng = num_(data.lng, NaN);
    const speed_mps = num_(data.speed_mps, 0);
    const timestamp = str_(data.timestamp) || new Date().toISOString();

    if (!route) return json_({ ok: false, error: 'Missing busId/route' });
    if (!driver) return json_({ ok: false, error: 'Missing driver' });
    if (!Number.isFinite(lat) || !Number.isFinite(lng)) {
      return json_({ ok: false, error: 'Invalid coordinates' });
    }

    const sh = getOrCreateSheet_(route);
    insertTopAndPrune_(sh, { timestamp, lat, lng, destination, driver, plate, speed_mps });

    return json_({ ok: true });
  } catch (err) {
    return json_({ ok: false, error: String(err) });
  }
}

/** JSON response helper */
function json_(obj) {
  return ContentService
    .createTextOutput(JSON.stringify(obj))
    .setMimeType(ContentService.MimeType.JSON);
}
